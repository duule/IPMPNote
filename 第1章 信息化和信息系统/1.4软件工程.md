
## 软件工程

- 软件工程的定义
	- 应用计算机科学、数学及团里科学等原理，以工程化的原则和方法来解决软件问题的工程。
	- 将系统的、规范的、可度量的工程化方法应用于软件开发、运行和维护的全过程及上述方法的研究。（IEEE的软件工程标准词汇表）
- 软件工程的目的：提高软件生产率、提高软件质量、降低软件成本。
- 软件工程的组成
	- 方法：完成软件工程项目的技术手段，它支持整个软件生命周期。
	- 工具：人们在开发软件的活动中智力和体力的扩展，它自动或半自动地支持软件的开发和管理，支持各种软件文档的生成。
	- 过程：贯穿于软件开发的各个环节，管理人员在软件工程过程中，要对软件开发的质量、进度、成本进行评估、管理和控制，包括人员组织、计划跟跟踪与控制、成本估算、质量保证和配置管理等。

### 需求分析

- 软件需求的定义
	- 用户对新系统在功能、行为、性能、设计约束等方面的期望。
	- 用户解决问题或达到目标所需的条件或能力，是系统或系统部件要满足合同、标准、规范或其他正式规定文档所需具有的条件或能力，以及反映这些条件或能力的文档说明。（IEEE的软件工程标准词汇表）
	- 系统必须完成的事以及必须具备的品质。
- 需求的层次（从目标到具体、从整体到局部、从概念到细节）
	- 业务需求：反映企业或客户对系统高层次的目标要求。
		- 通常来自项目投资人、购买产品的客户、客户单位的管理人员、市场营销部门、策划部门等
		- 业务需求可以确定项目视图和范围，为以后的开发工作奠定了基础。
	- 用户需求：用户的具体目标，或用户要求系统必须能完成的任务。
		- 通常采用用户访谈和问卷调查等方式，对用户使用的场景(scenarios)进行整理，从而建立用户需求。
	- 系统需求：从系统的角度来说明软件的需求，包括功能需求、非功能需求和设计约束等。
		- 功能需求（行为需求）：规定了开发人员必须在系统中实现的软件功能，用户利用这些功能来完成任务，满足业务需求。
		- 非功能需求：系统必须具备的属性或品质
			- 软件质量属性：可维护性、效率
			- 其他非功能需求
		- 设计约束（限制条件、补充规约）
- 质量功能部署(Quality Function Deployment, QFD)：将用户要求转化成软件需求的技术。
	- QFD的目的：最大限度地提升软件工程过程中用户的满意度。
	- QFD将软件需求分为三类
		- 常规需求：用户认为系统应该做到的功能或性能，实现越多用户会越满意。
		- 期望需求：用户想当然认为系统应具备的功能或性能，但并不能正确描述自己想要得到的这些功能或性能需求。如果期望需求没有得到实现，会让用户感到不满意。
		- 意外需求（兴奋需求）：用户要求范围外的功能或性能，实现这些需求用户会更高兴，但不实现也不影响其购买的决策。
- 需求获取：确定和理解不同的项目干系人的需求和约束的过程。
	- 需求获取方法
		- 用户访谈
		- 问卷调查
		- 采样
		- 情节串联板
		- 联合需求计划
- 需求分析
	- 好的需求该具有的特性
		- 无二义性
		- 完整性
		- 一致性
		- 可测试性
		- 确定性
		- 可跟踪性
		- 正确性
		- 必要性
	- 需求分析：提炼、分析和审查已经获取到的需求，以确保所有的项目干系人都明白其含义并找出其中的错误、遗漏或其他不足的地方。
	- 需求分析的关键在于问题域的研究与理解
	- 为便于理解问题域，现代软件工程方法所推荐的做法是对问题域进行抽象，将其分解为若干个基本元素，然后对元素之间的关系进行建模。
	- 使用SA(Structure Analysis)方法进行需求分析
		- 建立的模型的核心是数据字典
		- 三个层次的模型
			- 数据模型：一般使用实体联系图(E-R图,Entity Relationship Diagram)表示。
				- E-R图主要描述实体、属性，以及实体之间的关系。
			- 功能模型：一般用数据流向图(Data Flow Diagram, DFD)表示。
				- DFD从数据传递和加工的角度，利用图形符号通过逐层细分描述系统内各个部件的功能和数据在它们之间的传递清凉，来说明系统所完成的功能。
			- 行为模型（状态模型）：一般用状态转换图(State Transform Diagram, STD)表示。
				- STD通过描述系统的状态和引起系统状态转换的事件，来表示系统的行为，指出作为特定事件的结果将执行哪些动作（如处理数据等）。
	- OOA(Object-Oriented Analysis, 面向对象分析方法)
		- OOA的任务：运用OO方法，对问题域进行分析和理解，正确认识其中的事务及其它们之间的关系，找出描述问题域和系统功能所需的类和对象，定义它们的属性和职责，以及它们之间所形成的的各种联系。最终产生一个符合用户需求，并能直接反映问题域和系统功能的OOA模型及其详细说明。
		- OOA模型包括
			- 用例模型：一种描述系统需求的方法，使用用例的方法来描述系统需求的过程就是用例建模
			- 分析模型：描述系统的基本逻辑结构，展示对象和类如何组成系统（静态模型），以及它们如何保持通信，实现系统行为（动态模型）。
- 软件需求规格说明书(Software Requirement Specification, SRS)：需求开发活动的产物。
	- 编制SRS的目的：使项目干系人与开发团队对系统的初始规定有一个共同的理解，使之成为整个开发工作的基础。
	- SRS应该包括的内容（GB/T 8567-2006中规定）
		- 范围
			- SRS适用的系统和软件的完整标识：标识号、标题、缩略词语、版本号、发行号；
			- 简述SRS适用的系统和软件的用途，简述系统和软件的一般特性；
			- 概述系统开发、运行和维护的历史；
			- 标识项目的投资方、需方、用户、承建方和支持机构；
			- 标识当前和计划的运行现场；
			- 列出其他相关文档；
			- 概述SRS的用途和内容，并描述与其使用有关的保密性和隐私性的要求；
			- 说明编写SRS所依据的基线。
		- 引用文件：列出SRS中引用的所有文档的编号、标题、修订版本和日期，还应标识不能通过正常供货渠道获得的所有文档的来源。
		- 需求
			- 所需的状态和方式
			- 需求概述
			- 需求规格
			- 软件配置项能力需求
			- 软件配置项外部接口需求
			- 软件配置项内部接口需求
			- 是硬性需求
			- 保密性和隐私性需求
			- 软件配置项环境需求
			- 计算机资源需求（硬件需求、硬件资源利用需求、软件需求、通信需求）
			- 软件质量因素
			- 设计和实现约束
			- 数据
			- 操作
			- 故障处理
			- 算法说明
			- 有关人员需求
			- 有关培训需求
			- 有关后勤需求
			- 包装需求
			- 其他需求
			- 需求的优先次序和关键程度
		- 合格性规定：定义一组合格性的方法，对于需求部分的每个需求，制定所使用的方法，以确保需求得到满足。
			- 合格性方法包括：测试、分析、审查和特殊的合格性方法（如专用工具、技术、过程、设施和验收限制等）。
		- 需求可追踪性：SRS中每个软件配置项的需求到其涉及的系统（或子系统）需求的双向可追踪性。
		- 尚未解决的问题
		- 注解：有助于理解SRS的一般信息。
			- 为理解SRS需要的术语和定义。
			- 所有缩略语和它们在SRS中的含义的字母序列表。
		- 附录：为便于维护SRS而单独编排的信息（如图标、分类数据等）。
- 需求验证(需求确认)
	- 需求验证的必要性：以SRS为基础进行后续开发工作，如果在开发后期或在交付系统之后才发现需求存在问题，这时修补需求错误就需要大量的工作；相对而言，在系统分析阶段，检测SRS中的错误所采取的任何措施将节省相当多的时间和资金。因此有必要对SRS的正确性进行验证，以确保需求符合良好特征。
	- 需求验证需要确定的内容
		- SRS正确地描述了预期的、满足项目干系人需求的系统行为和特征。
		- SRS中的软件需求是从系统需求、业务规格和其他来源中正确推导而来的。
		- 需求是完整的和高质量的。
		- 需求的表示在所有地方都是一致的。
		- 需求为继续进行系统设计、实现和测试提供了足够的基础。
	- 在实际工作中，一般通过需求评审和需求测试工作来对需求进行验证。
		- 需求评审：对SRS进行技术评审，发现那些二义性或不确定性的需求，为项目干系人提供在需求问题上达成共识的方法。
		- 需求测试：在业务需求基本明确，用户需求部分确定时，同步进行需求测试，及早发现问题，从而在需求开发阶段以较低的代价解决这些问题。
- UML(Unified Modeling Language, 统一建模语言)：一种定义良好、易于表达、功能强大且普遍适用的建模语言。
	- UML融入了软件工程领域的新思想、新方法和新技术，它的作用域不限于支持OOA和OOD，还支持从需求分析开始的软件开发的全过程。
	- UML的结构
		- 构造块
			- 事务(thing、建模元素)：UML的重要组成部分。
				- UML模型中最基本的OO构造块
					- 结构事务(structural things)：结构事务在UML模型中属于最静态的部分，代表概念上或物理上的元素。UML有七种结构事务：类、接口、协作、用例、活动类、构件、结点。
					- 行为事务(behavioral things, 动作事务)：行为事务是UML模型中的动态部分，代表时间和空间上的动作。
						- UML有两种主要的行为事务
							- 交互（内部活动）：由一组对象之间在特定上下文中，为达到特定目的而进行的一系列消息交换而组成的动作。（交互中组成动作的对象的每个操作都要详细列出，包括消息、动作次序（消息产生的动作）、连接（对象之间的连接））。
							- 状态机：有一系列对象的状态组成。
					- 分组事务(grouping thisng)：分组事务是UML模型中组织的部分，可以把它们看成是个盒子，模型可以在其中进行分解。UML只有一种分组事务，称为包。
						- 包：一种将有组织的元素分组的机制。
						- 包与构件的不同：包纯粹是一种概念上的事务，只存在于开发阶段；构件可以存在于系统运行阶段。
					- 注释事务(annotational things)：注释事务是UML模型的解释部分。
			- 关系(relationship)：把事务紧密联系在一起。
				- 依赖(dependency)：两个事物之间的语义关系，其中一个事务发生变化会影响另一个事务的语义。
				- 关联(association)：一组对象之间连接的结构关系。
				- 泛化(generalization)：一般化和特殊化的关系，描述元素的对象可替换一般元素的对象。
				- 实现(realization)：类之间的语义关系，其中一个类指定了由另一个类保证执行的契约。
			- 图(diagram)：多个相互关联的事务的集合。
				- 类图(class diagram)[最常见]：描述一组类、接口、协作和它们之间的关系。
					- 类图给出了系统的静态设计视图，活动类的类图给出了系统的静态进程视图。
				- 对象图(object diagram)：描述一组对象及它们之间的关系。
					- 对象图描述了在类图中所建立的事务实例的静态快照。
					- 对象图给出了系统的静态设计视图或静态进程视图，但它们是从真实案例或原型案例的角度建立的。
				- 构件图(component diagram)：描述一个封装的类和它的接口、端口，以及由内嵌的构件和连接件构成的内部结构。
					- 构件图用于表示系统的静态设计实现视图。
					- 对于由小的部件构件的大系统来说，构件图是很重要的。
					- 构件图是类图的变体。
				- 组合构件图(composite structure diagram)：描述结构化类（如构件或类）的内部结构，包括结构化类与系统其余部分的交互点。
					- 组合构件图用于画出结构化类的内部内容。
				- 用例图(use case diagram)：描述一组用例、参与者及它们之间的关系。
					- 用例图给出系统的静态用例视图。
					- 这些图在对系统的行为进行组织和建模时是非常重要的。
				- 顺序图(sequence diagram, 序列图)：一种交互图(interaction diagram)，交互图展现了一种交互，它由一组对象或参与者以及它们之间可能发送的消息构成。
					- 交互图专注于系统的动态视图。
					- 顺序图的强调消息的时间次序的交互图。
				- 通信图(communication diagram、协作图, collaboration diagram)：一种交互图，他强调收发消息的对象或参与者的结构组织（关系）。
				- 定时图(timing diagram, 计时图)：一种交互图，他强调消息跨越不同对象或参与者的实际时间，而不仅仅只是关心消息的相对顺序。
				- 状态图(state diagram)：描述一个状态机，它由状态、转移、事件和活动组成
					- 状态图给出了对象的动态视图。
					- 他对于接口、类或协作的行为建模尤为重要，而且它强调事件导致的对象行为，这非常有助于对反应式系统建模。
				- 活动图(activity diagram)：将进程和其他计算结构展示为计算内部一步步的控制流和数据流。
					- 活动图专注于系统的动态视图。
					- 它对系统的功能建模和业务流程建模特别重要，并强调对象间的控制流程。
				- 部署图(deployment diagram)：描述对运行时的处理节点及其中生存的构件的配置。
					- 部署图给出了架构的静态部署视图，通常一个节点包含一个或多个部署图。
				- 制品图(artifact diagram)：描述计算机中一个系统的物理结构。
					- 制品包括：文件、数据库和类似的物理比特集合。
					- 制品图通常与部署图一起使用。制品图给出了它们实现的类和构件。
				- 包图(package diagram)：描述由模型本身分解而成的组织单元，以及它们之间的依赖关系。
				- 交互概览图(interaction onverview diagram)：活动图和顺序图的混合物。
		- 规则：构造块如何放在一起的规定。
			- 为构造块命名
			- 范围：给定一个名字以特定含义的语境。
			- 可见性：怎样使用或看见名字。
			- 完整性：事务如何正确、一致地相互联系。
			- 执行：运行或模拟动态模型的含义是什么。
		- 公共机制：达到特定目标的公共UML方法。
			- 规格说明（详细说明）
			- 修饰
			- 公共分类（通用划分）
			- 扩展机制
	- UML视图
		- UML对系统架构的定义：系统的组织结构，包括系统分解的组成部分，以及它们的关联性、交互机制和指导原则等提供系统设计的信息。
		- 5个系统视图
			- 逻辑视图（设计视图）：表示设计模型中在架构方面具有重要意义的部分，即类、子系统、包和用例实现的子集。
			- 进程视图：可执行线程和进程作为活动类的建模，它是逻辑视图的一次执行实例，描述了并发与同步结构。
			- 实现视图：对组成基于系统的物理代码的文件和构件进行建模。
			- 部署视图：把构件部署到一组物理节点上，表示软件到硬件的映射和分布结构。
			- 用例视图：最基本的需求分析模型。
	- UML模型允许在一定的阶段隐藏模型的某些元素、遗漏某些元素，以及不保证模型的完整性，但模型逐步地要达到完整和一致。
- 面向对象分析(Object-Oriented Analysis)
	- OOA的任务：运用OO的方法，对问题域进行分析和理解，正确认识其中的事务及它们之间的关系，找出描述问题域和系统功能所需的类和对象，定义它们的属性和职责，以及它们之间所形成的各种联系。最终产生一个符合用户需求，并能直接反映问题域和系统功能的OOA模型及其详细说明。
	- OOA模型独立于具体实现，即不考虑与系统具体实现有关的因素。
	- OOA和OOD的区别：OOA的任务是“做什么”，OOD的任务是“怎么做”。
	- OOA阶段的核心工作是建立系统的用例模型与分析模型。
	- 用例模型
		- 结构化分析(SA)方法采用功能分解的方式来描述系统功能，在这种表达方式中，系统功能被分解到各个功能模块中，通过描述细分的系统模块的功能来达到描述整个系统的目的
		- SA方法的缺点
			- 很容易混淆需求和设计的界限，这样的描述实际上已经包含了部分的设计在内。（极端的做法：将需求详细到概要设计，这样的需求描述既包含了外部需求也包含了内部设计）。
			- 分割了各项系统功能的应用环境，从各项功能项入手，很难了解到这些功能项如何相互关联来实现一个完整的系统服务的。
		- 用例方法的基本思想：用户并不想了解系统的内部结构和设计，他们所关心的是系统所能提供的服务。
		- 用力方法是一种需求合成技术，先获取需求，记录下来，然后从这些零散的要求和期望中进行整理与提炼，从而建立用例模型。
		- 在OOA方法中，构建用例模型的四个阶段
			- 识别参与者
				- 参与者：与系统交互的所有事务，该角色不仅可以由人承担，还可以是其他系统和硬件设备，甚至是系统时钟。（参与者一定在系统之外，不是系统的一部分。）
				- 可以用来识别参与者的方法/问题
					- 谁使用这个系统？
					- 谁安装这个系统？
					- 谁启动这个系统？
					- 谁维护这个系统？
					- 谁关闭这个系统？
					- 哪些（其他的）系统使用这个系统？
					- 谁从这个系统获取信息？
					- 谁为这个系统提供信息？
					- 是否有事情自动在预计的时间发生？
			- 合并需求获得用例：将参与者找到之后，接下来就是仔细地检查参与者，为每一个参与者确定用例
				1. 将获取到的需求分配给与其相关的参与者，以便可以针对每个参与者进行工作，而无遗漏
				2. 进行合并操作。
					- 合并之前，要明确为什么要合并，知道了合并的目的，才可能选择正确的合并。
					- 合并之后，将产生用例。
				3. 将识别到的参与者和合并生成的用例，通过用例图的形式整理出来，以获得用例模型的框架。
			- 细化用例描述
				- 用例建模的主要工作是书写用例规约（use case specification），而不是画图。
				- 用例模板为一个给定项目的所有人员定义了用例规约的结果，其内容至少包括用例名、参与者、目标、前置条件、事件流（基本事件流和扩展事件流）和后置条件等，其他的还可以包括非功能需求和用例优先级等。
			- 调整用例模型（非必须）：在建立了初步的用例模型后，还可以利用用例之间的关系来调整用例模型。利用用例之间的关系把一些公共的信息抽取出来，以便于复用，使得用例模型更易于维护。
				- 用例之间的关系
					- 包含关系：当可以从两个或两个以上的用例中提取出公共行为时，应该使用包含关系来表示他们。其中这个提取出来的公共用例称为抽象用例，而把原始用例称为基本用例或基础用例。
					- 扩展关系：如果一个用例明显地混合了两种或两种以上不同场景，即根据情况可能发生多种分支，则可以将这个用例分为一个基础用例和一个或多个扩展用例，这样使描述可能更加清晰。
					- 泛化关系：当多个用例共同拥有一种类似的结构和行为的时候，可以将他们的共性抽象成父用例，其他的用例作为泛化关系中的子用例。在用例的泛化关系中，子用例是父用例的一种特殊形式，子用例集成了父用例所有的结构、行为和关系。
	- 分析模型：描述系统的基本逻辑结构，展示对象和类如何组成系统（静态模型），以及它们如何保持通信，实现系统行为（动态模型）。
		- 领域模型（概念模型、域模型）：为了使模型独立于具体的开发语言，让系统分析师将注意力集中在概念性问题上，而不是软件技术问题上，将技术的起点称为领域模型，它是代表事务与概念的对象，即概念类。
		- 概念类可以从用例模型中获得灵感，经过完善将形成分析模型中的分析类。
		- 每一个用例对用一个类图，描述参与这个用例实现的所有概念类，而用例的实现主要通过交互图表示。
			- 例如：用例的事件流会对应产生一个顺序图：描述相关对象如何通过合作来完成整个事件流，复杂的备选事件流也可以产生一个或多个顺序图。
		- 所有这些图（类图、交互图）的集合就构成了系统的分析模型。
		- 建立分析模型的过程（其中前三个步骤称为CRC(Class-Responsibilitu-Collaborator)建模）
			1. 定义概念类
			2. 确定类之间的关系
			3. 为类添加职责
			4. 建立交互图
		- 类之间的关系
			- 关联关系：提供了不同类的对象之间的结构关系，它在一段时间内将多个类的实例连接在一起。（使用没有箭头的实线表示）
				- 关联体现的是对象实例之间的联系，而不表示两个类之间的关系。
				- 其余的关系涉及类元自身的描述，而不是他们的实例。
				- 对于关联关系的描述，可以使用关联名称、角色、多重性和导向性来说明
			- 依赖关系：两个类A和B，如果B的变化可能会引起A的变化，则称类A依赖于B。（使用一端实心箭头的虚线表示）
				- 依赖可以由各种原因引起，例如，一个类向另一个类发送消息，一个雷是另一个类的数据成员、一个类是另一个类的某个操作参数等。
			- 泛化关系：描述了一般事物与该事物中的特殊类之间的关系，也就是父类与子类之间的关系。（使用一端空心箭头的虚线表示）
				- 继承关系是泛化关系的反关系，也就是说，子类继承了父类，而父类则是子类的泛化。
			- 聚合关系（共享聚集）：表示类之间的整体与部分的关系，其含义是“部分”可能同时属于多个“整体”，“部分”与“整体”的生命周期可以不相同。（使用一端空心棱形的实线表示）
				- 例如：汽车和轮子就是聚合关系，车子坏了，车轮还可以用；车轮坏了可以再换个新的。
			- 组合关系（组合聚集）：表示类之间的整体与部分的关系。与聚合关系的区别在于，组合关系中的“部分”中能属于一个“整体”，“部分”与“整体”的生命周期相同，“部分”随着“整体”的创建而创建，也随着“整体”的消亡而消亡。（使用一端实心棱形的实线表示）
				- 例如：一个公司包含多个部门，它们之间的关系就是组合关系。公司一旦倒闭，也就没有部门了。
			- 实现关系：将说明和实现联系起来。（使用一端空心箭头的虚线表示）
				- 接口是对行为而非实现的说明，而类中则包含了实现的结构。一个或多个类可以实现一个接口，而每个类分别实现接口中的操作。

### 软件架构设计

- 软件架构设计提供了一个结构、行为和属性的高级抽象，由构件的描述、构件的相互作用（连接件）、指导构件集成的模式以及这些模式的约束组成。
- 软件架构不仅指定了系统的组织结构和拓扑结构，并且显示了系统需求和构件之间的对应关系，提供了一些设计决策的基本原理。
- 软件架构研究的主要内容
	- 软件架构描述
	- 软件架构风格：描述某一个特定应用领域中系统组织方式的惯用模式(idiomatic paradigm)。
		- 软件架构设计的一个核心问题：能否达到架构级的软件复用，也就是说，能否在不同的系统中，使用同一个软件架构。
		- 软件架构定义的内容
			- 架构定义
			- 词汇表：一些构件和连接件类型。
			- 一组约束：指出系统是如何将这些构件和连接件组合起来的。
		- 架构风格反映了领域中众多系统所共有的结构和语义特性，并指导如何将各个构件有效地组织成一个完整的系统。
		- 软件架构风格的分类（Garlan和Shaw提出）
			- 数据流风格：包括批处理序列和管道/过滤器两种风格。
			- 调用/返回风格：包括主程序/子程序、数据抽象和面向对象，以及层次结构。
			- 独立构件风格：包括进程通信和事件驱动的系统。
			- 虚拟机风格：包括解释器和基于规则的系统。
			- 仓库风格：包括数据库系统、黑板系统和超文本系统。
	- 软件架构评估
		- 软件架构评估可以只针对一个架构，也可以针对一组架构。
		- 在架构评估过程中，评估人员所关注的是系统的质量属性。
		- 敏感点(sensitivity point)：一个或多个构件（和/或构件之间的关系）的特性。
		- 权衡点(tradeoff point)：影响多个质量属性的特性，是多个质量属性的敏感点。
			- 例如：改变加密级别可能会对安全性和性能产生非常重要的影响。提高加密级别可以提高安全性，但可能耗费更多的处理时间，影响系统性能。如果某个机密消息的处理有严格的时间延迟要求，则加密级别可能会成为一个权衡点。
		- 软件架构评估的评估方式
			- 基于调查问卷（或检查表）的方式
			- 基于场景的方式[最常用]
				- 基于场景的方式主要包括
					- 架构权衡分析法(Architecture Tradeoff Analysis Method, ATAM)
					- 软件架构分析法(Software Architecture Analysis Method, SAAM)
					- 成本效益分析法(Cost Benefit Analysis Method, CBAM)
				- 在软件架构评估中，一般采用刺激、环境和响应三方面对场景进行描述。
					- 刺激(stimulus)：场景中解释或描述项目干系人怎样引发与系统的交互部分。
					- 环境(environment)：刺激发生时的情况。
					- 响应(response)：系统是如何通过架构对刺激做出反应的。
				- 基于场景的方式分析软件架构对场景的支持程度，从而判断盖家沟对这一场景所代表的质量需求的满足程度。
					- 例如
						- 用一系列对软件的修改来反映易修改性方面的需求；
						- 用一系列攻击性操作来代表安全性方面的需求。
				- 基于场景的方式考虑到了所有与系统相关的人员对质量的要求，涉及的基本活动包括
					- 确定应用领域的功能和软件架构之间的映射
					- 设计用于体现待评估质量属性的场景
					- 分析软件架构对场景的支持程度
				- 基于场景的评估方式是特定于领域的。因为不同的系统对同一质量属性的理解可能不同，存在不一致性，对一个领域适合的场景设计在另一个领域未必合适。
					- 例如
						- 对操作系统来说，可移植性被理解为系统可在不同的硬件平台上运行
						- 对于普通的应用系统而言，可移植性往往是指该系统可在不同的操作系统上运行。
				- 对基于场景的评估方式的实施者的要求
					- 需要有丰富的领域知识，以对某一质量需求设计出合理的场景；
					- 必须对待评估的软件架构有一定的了解，以准确判断它是否支持场景描述的一系列活动。
			- 基于度量的方式
	- 软件架构的形式化方法
- 软件架构的目的：解决好软件的复用、质量和维护问题。

### 软件设计

- 软件设计是需求分析的延伸与扩展。
- 需求分析阶段解决的是“做什么”的问题，软件设计阶段解决的是“怎么做的问题”。
- 软件设计是系统实施的基础，为系统实施工作做好铺垫。
- 合理的软件设计方案既可以保证系统的质量，也可以提高开发效率，确保系统实施工作的顺利进行。
- 软件设计的方法
	- 结构化设计：一种面向数据流的方法，它以SRS和SA阶段产生的DFD和数据字典等文档为基础，是一个自顶向下、逐步求精和模块化的过程。
		- SD方法的基本思想：将软件设计成由相对独立且具有单一功能的功能模块组成的结构。
		- SD方法的两个阶段
			- 概要设计（总体结构设计）：将系统的功能需求分配给软件模块，确定每个模块的功能和调用关系，形成软件的模块结构图，即结构图。
				- 概要设计中，将系统开发的总任务分解成许多个基本的、具体的任务。
			- 详细设计：为每个具体任务选择适当的技术手段和处理方法的过程。
				- 详细设计又可分为多种，例如：输入/输出设计、处理流程设计、数据存储设计、用户界面设计、安全性和可靠性设计等。
		- SD方法需要遵循的基本原则：高内聚，低耦合
			- 内聚：模块内部各成分之间的联系程度，是从功能角度来度量模块内联系的，一个好的内聚模块应当恰好做目标单一的一件事情。
			- 耦合：模块之间的联系程度。
				- 紧密耦合：模块之间联系非常强。
				- 松散耦合：模块之间联系比较弱。
				- 非耦合：模块之间无任何联系，是完全独立的。
	- 面向对象设计
		- OOD是OOA方法的延续。
		- OOD的基本思想包括抽象、封装和可扩展性，其中可扩展性主要通过继承和多态来实现。
		- 在OOD中，数据结构和数据结构上定义的操作算法封装在一个对象之中。
		- 由于现实世界中的事物都可以抽象出对象的集合，所有OOD方法是一种更接近现实世界、更自然的软件设计方法。
		- OOD的任务：对类和对象进行设计，包括类的属性、方法以及类与类之间的关系
		- OOD的结果就是设计模型
		- 对于OOD而言，在支持可维护性的同时，提高软件的可复用性是一个至关重要的问题，如何同时提高软件的可维护性和复用性，是OOD需要解决的核心问题之一，可维护性的复用是以设计原则为基础的。
		- 常用的OOD原则
			- 单一职责原则：设计功能单一的类。本原则与结构化方法的高内聚原则是一致的。
			- 开放-封闭原则：对扩展开放，对修改封闭。
			- 李氏(Liskov)替换原则：子类可以替换父类。
			- 依赖倒置原则：要依赖于抽象，而不是具体实现；针对接口编程，不要针对实现编程。
			- 接口隔离原则：使用多个专门的接口比使用单一的总接口要好。
			- 组合重用原则：要尽量使用组合，而不是继承关系达到重用目的。
			- 迪米特(Demeter)原则（最少知识法则）：一个对象应当对其他对象有尽可能少的了解。本原则与结构化方法的低耦合原则是一致的。
- 设计模式：前人经验的总结，它使人们可以方便地复用成功的软件设计。
	- 当人们在特定的环境下遇到特定类型的问题，采用他人已经使用过的一些成功的解决方案，一方面可以降低分析、设计和实现的难度，另一方面可以使系统具有更好的复用性和灵活性。
	- 设计模式包含模式名称、问题、目的、解决方案、效果、实例代码和相关设计模式等基本要素。
	- 根据处理范围不同对设计模式分类
		- 类模式：处理类与子类之间的关系，这些关系通过继承建立，在编译时刻就被确定下来，属于静态关系。
		- 对象模式：处理对象之间的关系，这些关系在运行时刻变化，更具动态性。
	- 根据目的和用途不同对设计模式分类
		- 创建型(Creational)模式：用于创建对象。
			- 工厂方法模式
			- 抽象工厂模式
			- 原型模式
			- 单例模式
			- 建造者模式
		- 结构型(Structural)模式：用于处理类或对象的组合。
			- 适配器模式
			- 桥接模式
			- 组合模式
			- 装饰模式
			- 外观模式
			- 享元模式
			- 代理模式
		- 行为型(Behavioral)模式：用于描述类或对象的交互以及职责的分配。
			- 职责链模式
			- 命令模式
			- 解释器模式
			- 迭代器模式
			- 中介者模式
			- 备忘录模式
			- 观察者模式
			- 状态模式
			- 策略模式
			- 模板方法模式
			- 访问者模式

### 软件工程的过程管理

- 改进软件过程的管理是解决无规则和混乱管理条件导致的软件开发技术和工具不能发挥应有作用难题的突破口。
- 为了做出客观、公正的比较，就需要建立一种衡量的标准。
	- 可以评价软件开发方面的质量保证能力，在软件项目评标活动中选择开发方。
	- 成为软件组织加强质量管理和提高软件产品质量的依据。
- 软件过程：软件生命周期中的一系列相关活动，即用于开发和维护软件及相关产品的一系列活动。
- 软件产品的质量取决于软件过程，具有良好的软件过程的组织能够开发出质量高的软件产品。
- 在软件过程管理方面，最著名的是能力成熟度模型集成（Capability Maturiry Model Integration, CMMI），它融合了多种模型，形成了组织范围内过程改进的单一集成模型。
	- CMMI的目的：消除不同模型之间的不一致和重复，降低基于模型进行改进的成本。
	- CMMI继承了CMM的阶段表示法和EIA/IS731的连续式表达方法。这两种表达方法各有优缺点，均采用统一的24个过程域，它们在逻辑上是等价的，对统一组织采用两种模型分别进行CMMI评估，得到的结论应该是相同的。
		- 阶段式模型：基本沿袭CMM模型框架，仍保持4个成熟等级，但关键过程域做了一些调整和扩充

			|成熟度等级|过程域|
			|--:|:--|
			|可管理等级|需求管理、项目计划、配置管理、项目监督与控制、供应商合同管理、度量和分析、过程和产品质量保证|
			|已定义级|需求开发、技术解决方案、产品集成、验证、确认、组织级过程焦点、组织级过程定义、组织级培训、集成项目管理、风险管理、集成化的团队、决策分析和解决方案、组织级集成环境|
			|量化管理级|组织级过程性能、定量项目管理|
			|优化管理级|组织级改革与实施、因果分析和解决方案|
			
			- 当组织通过了某一等级过程域中的全部过程，即意味着该组织的成熟度达到了这一等级。
			- 利用阶段式模型对组织进行成熟度度量，概念清晰、易于理解、便于操作。
		- 连续式模型：与阶段式模型相比，连续式模型没有与组织成熟度相关的几个阶段。连续式模型将24个过程域按照功能划分为过程管理、项目管理、工程和支持过程组。
			
			|连续式分组|过程域|
			|--:|:--|
			|过程管理|组织级过程焦点、组织级过程定义、组织级培训、组织级过程性能、组织级改革与实施|
			|项目管理|项目计划、项目监督与控制、供应商合同管理、集成项目管理、风险管理、集成化的团队、定量项目管理|
			|工程|需求管理、需求开发、技术解决方案、产品集成、验证、确认|
			|支持|配置管理、度量和分析、过程和产品质量保证、决策分析和解决方案、组织级集成环境、因果分析和解决方案|

### 软件测试及其管理

- 软件测试：将软件交付给客户之前所必须完成的重要步骤。
- 软件测试是发现软件错误（缺陷）的主要手段。
- 软件测试的目的（国家标准《计算机软件测试规范(GB/T 15532-2008)》）：验证软件是否满足软件开发合同或项目开发计划、系统/子系统设计文档、SRS、软件设计说明和软件产品说明等规定的软件质量要求。
- 通过测试，发现软件缺陷，为软件产品的质量测量和评价提供依据。
- GB/T 15532-2008还规定了测试用例设计原则和测试用例要素。
	- 测试用例设计原则
		- 基于测试需求的原则
		- 基于测试方法的原则
		- 兼顾测试充分性和效率的原则
		- 测试执行的可再现性原则
	- 测试用例要素
		- 名称和标识
		- 测试追踪
		- 用例说明
		- 测试的初始化要求
		- 测试的输入
		- 期望的测试结果
		- 评价测试结果的准则
		- 操作过程
		- 前提和约束
		- 测试终止条件
- 测试的方法
	- 静态测试：被测试程序不在机器上运行，而采用人工检测和计算机辅助静态分析的手段对程序进行检测。
		- 对文档的静态测试：主要以检查单的形式进行。
		- 对代码的静态测试：一般采用桌前检查（Desk Checking）、代码走查和代码审查进行。
			- 经验表明这种方法能够有效地发现30%-70%的逻辑设计和编码错误。
	- 动态测试：在计算机上实际运行程序进行软件测试。
		- 白盒测试（结构测试）
			- 主要用于软件单元测试中。
			- 白盒测试的主要思想：将程序看做是一个透明的白盒，测试程序中的主要执行通路是否都能按预定的要求正确工作。
			- 白盒测试方法主要有控制流测试、数据流测试和程序异变测试等。
			- 静态测试的方法也可以实现白盒测试
				- 例如：使用人工检查代码的方法来检查代码的逻辑问题，也属于白盒测试的范畴。
			- 白盒测试方法中，最常见的技术是逻辑覆盖：使用测试数据运行被测程序，考察对程序逻辑的覆盖程度。
				- 主要的覆盖标准有
					- 语句覆盖
					- 判定覆盖
					- 条件/判定覆盖
					- 条件组合覆盖
					- 修正的条件/判定覆盖
					- 路径覆盖
		- 黑盒测试（功能测试）
			- 主要用于集成测试、确认测试和系统测试中。
			- 黑盒测试的主要思想：将程序看做是一个不透明的黑盒，完全不考虑（或不了解）程序的内部结构和处理算法，而只检查程序功能是否按照SRS的要求正常使用，程序是否能是当地接收输入数据并产生正确的输出信息，程序运行过程中能否保持外部信息（例如：文件和数据库等）的完整性等。
			- 黑盒测试根据SRS所规定的的功能来设计测试用例，一般包括
				- 等价类划分
				- 边界值分析
				- 判定表
				- 因果图
				- 状态图
				- 随机测试
				- 猜错法
				- 正交试验法
- 测试的类型（GB/T 15532-2008）
	- 单元测试（模块测试）
		- 测试的对象是可独立编译或汇编的程序模块、软件构件或OO软件中的类（统称为模块）。
		- 单元测试的目的：检查每个模块能否正确地实现设计说明中的功能、性能、接口和其他设计约束等条件，发现模块内可能存在的各种差错。
		- 单元测试的技术依据是软件详细设计说明书，着重从模块接口、局部数据结构、重要的执行通路、出错处理通路和边界条件等方面对模块进行测试。
	- 集成测试
		- 集成测试的目的：检查模块之间，以及模块和已集成的软件之间的接口关系，并验证已集成的软件是否符合设计要求。
		- 集成测试的技术依据是软件概要设计文档。
		- 除应满足一般的测试准入条件外，在进行集成测试前还应确认待测试的模块均已通过单元测试。
	- 确认测试
		- 主要用于验证软件的功能、性能和其它特性是否与用户需求一致。
		- 根据用户的参与程度分类
			- 内部确认测试：主要由软件开发组织内部按照SRS进行测试。
			- Alpha测试：对于通用产品型的软件开发而言，由用户在开发环境下进行测试，通过Alpha测试以后的产品通常称为Alpha版。
			- Beta测试：对于通用产品型的软件开发而言，由用户在实际使用环境下进行测试，通过Beta测试的产品通常称为Beta版。一般在通过Beta测试后，才能把产品发布或交付给用户。
			- 验收测试：针对SRS，在交付前以用户为主进行的测试。其测试对象为完整的、集成的计算机系统。
				- 验收测试的目的：在真实的用户工作环境下，检查软件系统是否满足开发技术合同或SRS。
				- 验收测试的结论是用户确定是否接收该软件的主要依据。
				- 除应满足一般测试的准入条件外，在进行验收测试之前，应确认被测试软件系统已通过系统测试。
	- 系统测试
		- 系统测试的对象是完整的、集成的计算机系统。
		- 系统测试的目的：在真实的工作环境下，验证完整的软件配置项能否和系统正确连接，并满足系统/子系统设计文档和软件开发合同规定的要求。
		- 系统测试的技术依据是用户需求或开发合同。
		- 除应满足一般测试的准入条件外，在进行系统测试前，还应确认被测试系统的所有配置项已通过测试，对需要固化运行的软件还应提供固件。
		- 系统测试的主要内容包括
			- 功能测试[最重要]：主要采用黑盒测试方法。
			- 健壮性测试
			- 性能测试[最重要]：主要验证软件系统在承担一定负载的情况下所表现出来的特性是否符合客户的需要。
				- 主要指标有
					- 响应时间
					- 吞吐量
					- 并发用户数
					- 资源利用率
			- 用户界面测试
			- 安全性测试
			- 安装与反安装测试
	- 配置项测试
		- 配置项测试的对象是软件配置项。
		- 配置项测试的目的：检验软件配置项与SRS的一致性。
		- 配置项测试的技术依据是SRS（含接口需求规格说明书）。
		- 除应满足一般测试的准入条件外，在进行配置项测试之前，还应确认被测试软件配置项已通过单元测试和集成测试。
	- 回归测试
		- 回归测试的目的：软件测试变更之后，变更部分的正确性和对变更需求的符合性，以及软件原有的、正确的功能、性能和其他规定的要求的不损害性。
		- 回归测试的对象
			- 未通过软件单元测试的软件，在变更后，应对其进行单元测试。
			- 未通过配置项测试的软件，在变更后，首先应对变更的软件单元进行测试，然后再进行相关的集成测试和配置项测试。
			- 未通过系统测试的软件，在变更后，首先应对变更的软件进行单元测试，然后再进行相关的集成测试、配置测试和系统测试。
			- 因其他原因进行变更之后的软件单元，也首先应对变更的软件单元进行测试，然后再进行相关的软件测试。
- 面向对象的测试
	- OO系统的测试目标与传统信息系统的测试目标是一致的，但OO系统的测试策略与传统的结构化系统的测试策略有很大的不同，这些不同主要体现在两个方面
		- 测试的焦点从模块转向了类。
		- 测试的视角扩大到了分析和设计模型。
	- OO系统具有三个明显特征
		- 封装性：决定了OO系统的测试必须考虑到信息隐蔽原则对测试的影响，以及对象状态与类的测试序列；
		- 继承性：决定了OO系统的测试必须考虑到继承对测试充分性的影响，以及误用引起的错误；
		- 多态性：决定了OO系统的测试必须考虑到动态绑定对测试充分性的影响、抽象类的测试，以及误用对测试的影响。
- 软件调试（排错）
	- 软件调试与成功的测试形影相随。
	- 测试成功的标志是发现了错误，根据错误迹象确定错误的原因和准确位置，并加以改正，主要依靠软件调试技术。
	- 隐藏在程序中的错误具有的特殊性质
		- 错误在外部征兆原理引起错误的内部原因，对于高度耦合的程序结构，此类现象更为严重。
		- 纠正一个错误造成了另一个错误现象（暂时）的消失。
		- 某些错误征兆只是假象。
		- 因操作人员一时疏忽造成的某些错误征兆不易追踪。
		- 错误是由于分时而不是程序引起的。
		- 输入条件难以精确地再构造（例如：某些实时应用的输入次序不确定）。
		- 错误征兆时有时无，此现象对嵌入式系统尤为普遍。
		- 错误是由于把任务分布在若干台不同处理机上运行而造成的。
	- 软件调试策略
		- 蛮力法
		- 回溯法
		- 原因排除法
	- 软件调试与测试的区别
		- 测试的目的是招数存在的错误，调试的目的是定位错误并修改程序以修正错误。
		- 调试是测试之后的活动，测试和调试在目标、方法和思路上有所不同。
		- 测试从一个已知的条件开始，使用预先定义的过程，有预知的结果；调试从一个未知的条件开始，结束的过程不可预计。
		- 测试过程可以事先设计，进度可以实现确定；调试不能描述过程或持续时间。
- 软件测试管理
	- 过程管理
		- 过程管理包括
			- 测试活动管理
			- 资源管理
		- 软件测试应由相对独立的人员进行。
		- 根据软件项目的规模、完整性级别和测试类别，软件测试可由不同机构组织实施。
		- 一般情况下软件测试人员应包括测试项目负责人、测试分析员、测试设计员、测试程序员、测试员、测试系统管理员和配置管理员等。
		- 开始软件测试工作应具备的条件（准入条件）
			- 具有测试合同（或项目计划）；
			- 具有软件测试所需的各种文档；
			- 所提交的被测试软件已受控；
			- 软件源代码已正确通过编译或汇编。
		- 结束软件测试工作应具备的条件（准入条件）
			- 已按要求完成了合同（或项目计划）所规定的的软件测试任务；
			- 实际测试过程遵循了原定的软件测试计划和测试说明；
			- 客观、详细地记录了软件测试过程和软件测试中发现的所有问题；
			- 软件测试文档齐全，符合规范；
			- 软件测试的全过程自始至终在控制下进行；
			- 软件测试中的问题或异常有合理解释或正确有效的处理；
			- 软件测试工作通过了测试评审；
			- 全部测试工具、被测软件、测试支持软件和评审结果已纳入配置管理。
	- 配置管理
		- 应按照软件配置管理的要求，将测试过程中产生的各种工作产品纳入配置管理。
			- 由开发组织实施的软件测试，应将测试工作产品纳入软件项目的配置管理；
			- 由独立测试组织实施的软件测试，应建立配置管理库，将被测试对象和测试工作产品纳入配置管理。
	- 评审
		- 测试过程中的评审包括
			- 测试就绪评审：在测试执行前对测试计划和测试说明等进行评审，评审测试计划的合理性和测试用例的正确性、完整性和覆盖充分性，以及测试组织、测试环境和设备、工具是否齐全并符合技术要求等。
			- 测试评审：在测试完成后，评审测试过程和测试结果的有效性，确定是否达到测试目的，主要对测试记录和测试报告进行评审。

### 软件集成技术

- 信息孤岛的形成：在企业信息化建设的过程中，由于缺乏统一规划和总体布局导致。
- 信息孤岛使数据的一致性无法得到保证，信息无法共享和反馈，需要重复多次的采集和输入。
- 信息孤岛是企业信息化的一个重要的负面因素，其主要原因既有技术因素也有管理因素，还有业务流程和标准方面的因素。
- 软件层次的集成技术：企业应用集成（Enterprise Application Integration, EAI）
- 企业可以应用集成技术消除信息孤岛，将多个企业信息系统连接起来，实现无缝集成，使他们像一个整体一样。
- EAI所连接的应用包括各种电子商务系统、ERP、CRM、SCM、OA、数据库系统和数据仓库等。
- 从单个企业的角度来说，EAI可以包括
	- 表示集成（界面集成）[常用]：将用户界面作为公共的集成点，把原有零散的系统界面集中在一个新的界面中。
		- 表示集成是黑和集成，无需了解程序与数据库的内部构造。
		- 常用的表示集成技术主要有屏幕截取和输入模拟技术。
		- 表示集成通常应用于以下几种情况
			- 在现有的基于终端的应用系统上配置基于PC的用户界面。
			- 为用户提供一个看上去统一，但是由多个系统组成的应用系统。
			- 当只有可能在显示界面上实现集成时。
		- 表示集成的实现是很简单的，也是很不彻底的，只是做了一层“外装修”，而额外多出来的集成界面也将可能成为系统的性能瓶颈。
	- 数据集成
		- 数据集成是白盒集成。
		- 为了完成控制集成和业务流程集成，必须首先解决数据和数据库的集成问题。
		- 在集成之前，必须首先对数据进行标识并编程目录，另外还要确定元数据模型，保证数据在数据库系统中分布和共享。
		- 数据集成的集成点在中间件层。
		- 很多不同的中间件工具可以用于数据集成
			- 例如
				- 批量文件传输，即以特定的或是预定的方式在原有系统和新开发的系统之间进行文件传输；
				- 用于访问不同类型数据库的ODBC标准接口；
				- 向分布式数据库提供连接的数据库访问中间件技术。
		- 数据集成通常应用于以下几种情况
			- 需要对多种信息源产生是数据进行综合分析和决策。
			- 要处理一些多个应用需要访问的公共信息库。
			- 当需要从某数据源获得数据来更新另一个数据源时，特别是它们之间的数据格式不相同时。
		- 数据集成比表示集成更加灵活，但是业务逻辑经常发生变化时，数据集成就会面临困难。
	- 控制集成（功能集成、应用集成）：在业务逻辑层上对应用系统进行集成。
		- 控制集成是黑盒集成。
		- 控制集成的集成点存在于程序代码中，集成处可能只是简单使用公开的API(Application Programming Interface, 应用程序变成接口)就可以访问，也可能需要添加附加的代码来实现。
		- 实现控制集成时，可以借助于远程过程调用或远程方法调用、面向消息的中间件、分布式对象技术和事务处理监控器来实现。
		- 控制集成与表示集成、数据集成相比，灵活性更高。
		- 表示集成和数据集成适用的环境下，都适用于控制集成。
		- 由于控制集成是在业务逻辑层进行的，其复杂度更高一些。而且很多系统的业务逻辑部分并没有提供API，这样，集成的难度就会更大。
	- 业务流程集成（过程集成）
		- 这种集成超越了数据和系统，它由一系列基于标准的、统一数据格式的工作流组成。
		- 当进行业务流程集成时，企业必须对各种业务信息的交换进行定义、授权和管理，以便改进操作、减少成本、提高响应速度。
		- 业务流程进程不仅要提供底层应用支撑系统之间的互连，同时要实现存在于企业内部的应用之间，本企业和其他合作伙伴之间的端到端的业务流程的管理，它包括应用集成、B2B集成、自动化业务流程管理、人工流程管理、企业门户，以及对所有应用系统和流程的管理和监控等。
- 从多个企业的角度来说，EAI可以包括
	- 企业之间的应用集成
		- EAI技术可以适用于大多数要实施电子商务的企业，以及企业之间的应用集成。
		- EAI使得应用集成架构里的客户和业务伙伴，都可以通过集成供应链内的所有应用和数据库实现信息共享。能使企业充分利用外部资源。
			- 例如
				- 一些企业的SCM系统可能包括交易系统，EAI技术可以首先在交易双方之间创建连接，然后再共享数据和业务过程；
				- 企业要顺利开展电子商务，可以利用EAI技术，使企业的信息系统与合作伙伴的信息系统之间能够实现无缝而及时的通信。